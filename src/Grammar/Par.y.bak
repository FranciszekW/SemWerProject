-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Grammar.Par
  ( happyError
  , myLexer
  , pType
  , pFType
  , pVarIdent
  , pArrIdent
  , pDictIdent
  , pFuncIdent
  , pExpr
  , pIExpr
  , pIExpr1
  , pIExpr2
  , pBExpr1
  , pBExpr
  , pArgs
  , pLambda
  , pParams
  , pInstr1
  , pInstr
  ) where

import Prelude

import qualified Grammar.Abs
import Grammar.Lex

}

%name pType Type
%name pFType FType
%name pVarIdent VarIdent
%name pArrIdent ArrIdent
%name pDictIdent DictIdent
%name pFuncIdent FuncIdent
%name pExpr Expr
%name pIExpr IExpr
%name pIExpr1 IExpr1
%name pIExpr2 IExpr2
%name pBExpr1 BExpr1
%name pBExpr BExpr
%name pArgs Args
%name pLambda Lambda
%name pParams Params
%name pInstr1 Instr1
%name pInstr Instr
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'          { PT _ (TS _ 1)  }
  '!='         { PT _ (TS _ 2)  }
  '%'          { PT _ (TS _ 3)  }
  '%='         { PT _ (TS _ 4)  }
  '('          { PT _ (TS _ 5)  }
  ')'          { PT _ (TS _ 6)  }
  '*'          { PT _ (TS _ 7)  }
  '*='         { PT _ (TS _ 8)  }
  '+'          { PT _ (TS _ 9)  }
  '++'         { PT _ (TS _ 10) }
  '+='         { PT _ (TS _ 11) }
  ','          { PT _ (TS _ 12) }
  '-'          { PT _ (TS _ 13) }
  '--'         { PT _ (TS _ 14) }
  '-='         { PT _ (TS _ 15) }
  '->'         { PT _ (TS _ 16) }
  '/'          { PT _ (TS _ 17) }
  '/='         { PT _ (TS _ 18) }
  ':'          { PT _ (TS _ 19) }
  ';'          { PT _ (TS _ 20) }
  '<'          { PT _ (TS _ 21) }
  '<='         { PT _ (TS _ 22) }
  '='          { PT _ (TS _ 23) }
  '=='         { PT _ (TS _ 24) }
  '>'          { PT _ (TS _ 25) }
  '>='         { PT _ (TS _ 26) }
  'Array'      { PT _ (TS _ 27) }
  'Bool'       { PT _ (TS _ 28) }
  'BoolFunc'   { PT _ (TS _ 29) }
  'Dict'       { PT _ (TS _ 30) }
  'Int'        { PT _ (TS _ 31) }
  'IntFunc'    { PT _ (TS _ 32) }
  '['          { PT _ (TS _ 33) }
  ']'          { PT _ (TS _ 34) }
  'and'        { PT _ (TS _ 35) }
  'assignment' { PT _ (TS _ 36) }
  'break'      { PT _ (TS _ 37) }
  'continue'   { PT _ (TS _ 38) }
  'debug'      { PT _ (TS _ 39) }
  'disable'    { PT _ (TS _ 40) }
  'else'       { PT _ (TS _ 41) }
  'enable'     { PT _ (TS _ 42) }
  'false'      { PT _ (TS _ 43) }
  'for'        { PT _ (TS _ 44) }
  'has'        { PT _ (TS _ 45) }
  'if'         { PT _ (TS _ 46) }
  'key'        { PT _ (TS _ 47) }
  'lambda'     { PT _ (TS _ 48) }
  'none'       { PT _ (TS _ 49) }
  'or'         { PT _ (TS _ 50) }
  'outer'      { PT _ (TS _ 51) }
  'print'      { PT _ (TS _ 52) }
  'reading'    { PT _ (TS _ 53) }
  'return'     { PT _ (TS _ 54) }
  'set'        { PT _ (TS _ 55) }
  'skip'       { PT _ (TS _ 56) }
  'swap'       { PT _ (TS _ 57) }
  'to'         { PT _ (TS _ 58) }
  'true'       { PT _ (TS _ 59) }
  'while'      { PT _ (TS _ 60) }
  'xor'        { PT _ (TS _ 61) }
  '{'          { PT _ (TS _ 62) }
  '}'          { PT _ (TS _ 63) }
  L_Ident      { PT _ (TV $$)   }
  L_integ      { PT _ (TI $$)   }

%%

Ident :: { Grammar.Abs.Ident }
Ident  : L_Ident { Grammar.Abs.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Type :: { Grammar.Abs.Type }
Type : 'Int' { Grammar.Abs.TInt } | 'Bool' { Grammar.Abs.TBool }

FType :: { Grammar.Abs.FType }
FType
  : 'IntFunc' { Grammar.Abs.FTInt }
  | 'BoolFunc' { Grammar.Abs.FTBool }

VarIdent :: { Grammar.Abs.VarIdent }
VarIdent : Ident { Grammar.Abs.Var $1 }

ArrIdent :: { Grammar.Abs.ArrIdent }
ArrIdent : Ident { Grammar.Abs.Arr $1 }

DictIdent :: { Grammar.Abs.DictIdent }
DictIdent : Ident { Grammar.Abs.Dict $1 }

FuncIdent :: { Grammar.Abs.FuncIdent }
FuncIdent : Ident { Grammar.Abs.Func $1 }

Expr :: { Grammar.Abs.Expr }
Expr : IExpr { Grammar.Abs.IE $1 } | BExpr { Grammar.Abs.BE $1 }

IExpr :: { Grammar.Abs.IExpr }
IExpr
  : IExpr '+' IExpr1 { Grammar.Abs.EPlus $1 $3 }
  | IExpr '-' IExpr1 { Grammar.Abs.EMinus $1 $3 }
  | IExpr1 { $1 }

IExpr1 :: { Grammar.Abs.IExpr }
IExpr1
  : IExpr1 '/' IExpr2 { Grammar.Abs.EDiv $1 $3 }
  | IExpr1 '*' IExpr2 { Grammar.Abs.EMul $1 $3 }
  | IExpr1 '%' IExpr2 { Grammar.Abs.EMod $1 $3 }
  | IExpr2 { $1 }

IExpr2 :: { Grammar.Abs.IExpr }
IExpr2
  : Integer { Grammar.Abs.ENum $1 }
  | VarIdent { Grammar.Abs.EVar $1 }
  | VarIdent '++' { Grammar.Abs.EPostInc $1 }
  | '++' VarIdent { Grammar.Abs.EPreInc $2 }
  | VarIdent '--' { Grammar.Abs.EPostDec $1 }
  | '--' VarIdent { Grammar.Abs.EPreDec $2 }
  | ArrIdent '[' IExpr ']' { Grammar.Abs.EArray $1 $3 }
  | DictIdent '[' IExpr ']' { Grammar.Abs.EDict $1 $3 }
  | DictIdent '[' BExpr ']' { Grammar.Abs.EDictB $1 $3 }
  | FuncIdent '(' Args ')' { Grammar.Abs.EFuncVal $1 $3 }
  | '(' IExpr ')' { $2 }

BExpr1 :: { Grammar.Abs.BExpr }
BExpr1
  : 'true' { Grammar.Abs.BTrue }
  | 'false' { Grammar.Abs.BFalse }
  | VarIdent { Grammar.Abs.BVar $1 }
  | IExpr '==' IExpr { Grammar.Abs.BEq $1 $3 }
  | IExpr '<=' IExpr { Grammar.Abs.BLeq $1 $3 }
  | IExpr '>=' IExpr { Grammar.Abs.BGeq $1 $3 }
  | IExpr '<' IExpr { Grammar.Abs.BLt $1 $3 }
  | IExpr '>' IExpr { Grammar.Abs.BGt $1 $3 }
  | IExpr '!=' IExpr { Grammar.Abs.BNeq $1 $3 }
  | BExpr '==' BExpr { Grammar.Abs.BEqB $1 $3 }
  | BExpr '!=' BExpr { Grammar.Abs.BNeqB $1 $3 }
  | '!' BExpr1 { Grammar.Abs.BNot $2 }
  | BExpr 'or' BExpr1 { Grammar.Abs.BOr $1 $3 }
  | BExpr 'and' BExpr1 { Grammar.Abs.BAnd $1 $3 }
  | BExpr 'xor' BExpr1 { Grammar.Abs.BXor $1 $3 }
  | ArrIdent '[' IExpr ']' { Grammar.Abs.BArray $1 $3 }
  | DictIdent '[' IExpr ']' { Grammar.Abs.BDict $1 $3 }
  | DictIdent '[' BExpr ']' { Grammar.Abs.BDictB $1 $3 }
  | DictIdent 'has' 'key' '[' IExpr ']' { Grammar.Abs.BDictHasKey $1 $5 }
  | DictIdent 'has' 'key' '[' BExpr ']' { Grammar.Abs.BDictHasKeyB $1 $5 }
  | FuncIdent '(' Args ')' { Grammar.Abs.BFuncVal $1 $3 }
  | '(' BExpr ')' { $2 }

BExpr :: { Grammar.Abs.BExpr }
BExpr : BExpr1 { $1 }

Args :: { Grammar.Abs.Args }
Args
  : 'none' { Grammar.Abs.ArgsNone }
  | Expr { Grammar.Abs.ArgsOne $1 }
  | Expr ',' Args { Grammar.Abs.ArgsMany $1 $3 }

Lambda :: { Grammar.Abs.Lambda }
Lambda
  : FType 'lambda' '(' Params ')' '->' '{' Instr '}' { Grammar.Abs.Lambda $1 $4 $8 }

Params :: { Grammar.Abs.Params }
Params
  : 'none' { Grammar.Abs.ParamsNone }
  | VarIdent ':' Type { Grammar.Abs.ParamVar $1 $3 }
  | FuncIdent ':' FType { Grammar.Abs.ParamFunc $1 $3 }
  | Lambda { Grammar.Abs.ParamLambda $1 }
  | VarIdent ':' Type ',' Params { Grammar.Abs.ParamVarMany $1 $3 $5 }
  | FuncIdent ':' FType ',' Params { Grammar.Abs.ParamFuncMany $1 $3 $5 }
  | Lambda ',' Params { Grammar.Abs.ParamLambdaMany $1 $3 }

Instr1 :: { Grammar.Abs.Instr }
Instr1
  : 'skip' { Grammar.Abs.ISkip }
  | 'if' '(' BExpr ')' '{' Instr '}' 'else' '{' Instr '}' { Grammar.Abs.iif1 $3 $6 $10 }
  | 'if' '(' BExpr ')' '{' Instr '}' { Grammar.Abs.iif2 $3 $6 }
  | 'while' '(' BExpr ')' '{' Instr '}' { Grammar.Abs.IWhile $3 $6 }
  | 'for' '(' VarIdent '=' IExpr 'to' IExpr ')' '{' Instr '}' { Grammar.Abs.IFor $3 $5 $7 $10 }
  | 'return' '(' IExpr ')' { Grammar.Abs.IReturn $3 }
  | 'print' '(' IExpr ')' { Grammar.Abs.IPrint $3 }
  | 'swap' '(' VarIdent ',' VarIdent ')' { Grammar.Abs.ISwap $3 $5 }
  | 'break' '(' IExpr ')' { Grammar.Abs.IBreak $3 }
  | 'break' { Grammar.Abs.IBreak1 }
  | 'continue' 'outer' '(' IExpr ')' { Grammar.Abs.IContinue $4 }
  | 'continue' { Grammar.Abs.IContinue0 }
  | Type VarIdent '=' Expr { Grammar.Abs.VarDef $1 $2 $4 }
  | 'Array' Type ArrIdent '[' IExpr ']' '(' Expr ')' { Grammar.Abs.ArrDefInit $2 $3 $5 $8 }
  | 'Array' Type ArrIdent '[' IExpr ']' { Grammar.Abs.ArrDef $2 $3 $5 }
  | ArrIdent '[' IExpr ']' '=' '(' IExpr ')' { Grammar.Abs.ArrElSet $1 $3 $7 }
  | 'Dict' Type DictIdent { Grammar.Abs.DictDef $2 $3 }
  | DictIdent '[' IExpr ']' 'set' '(' IExpr ')' { Grammar.Abs.DictElSet $1 $3 $7 }
  | FType FuncIdent '(' Params ')' '{' Instr '}' { Grammar.Abs.FuncDef $1 $2 $4 $7 }
  | VarIdent '=' IExpr { Grammar.Abs.VarAssign $1 $3 }
  | VarIdent '+=' IExpr { Grammar.Abs.VarAssignPlus $1 $3 }
  | VarIdent '-=' IExpr { Grammar.Abs.VarAssignMinus $1 $3 }
  | VarIdent '*=' IExpr { Grammar.Abs.VarAssignMul $1 $3 }
  | VarIdent '/=' IExpr { Grammar.Abs.VarAssignDiv $1 $3 }
  | VarIdent '%=' IExpr { Grammar.Abs.VarAssignMod $1 $3 }
  | 'debug' 'assignment' 'enable' VarIdent { Grammar.Abs.DebugAssEnable $4 }
  | 'debug' 'assignment' 'disable' VarIdent { Grammar.Abs.DebugAssDisable $4 }
  | 'debug' 'reading' 'enable' VarIdent { Grammar.Abs.DebugReadEnable $4 }
  | 'debug' 'reading' 'disable' VarIdent { Grammar.Abs.DebugReadDisable $4 }

Instr :: { Grammar.Abs.Instr }
Instr : Instr1 ';' Instr { Grammar.Abs.ISeq $1 $3 } | Instr1 { $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

