{-

This file contains the grammar of FraJer plus explanations how to render them
in BNFC.

-}

-- Syntax for comments
comment "//" ;
comment "/*" "*/" ;

-- --------------------------------------------------------------------------------------------- --

-- BNFC Expressions for types and identifiers
-- T ::= int | bool
-- FT ::= Ifun | Bfun

TInt.  Type ::= "Int";
TBool. Type ::= "Bool";
FTInt. FType ::= "IntFunc";
FTBool. FType ::= "BoolFunc";

Var. VarIdent ::= Ident;
Arr. ArrIdent ::= Ident;
Dict. DictIdent ::= Ident;
Func. FuncIdent ::= Ident;

{-
_. Ident ::= VarIdent;
_. Ident ::= ArrIdent;
_. Ident ::= DictIdent;
_. Ident ::= FuncIdent;
-}

-- --------------------------------------------------------------------------------------------- --

-- BNFC Expressions for general expressions
-- E ::= Ie | Be

IE. Expr ::= IExpr;
BE. Expr ::= BExpr;

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for int expressions
-- Ie ::= N | x | Ie1 + e2 | Ie1 ∗ e2 | Ie1 − e2 | Ie1 % Ie2 | Ie1 / Ie2
--          | x++ | ++x | x-- | --x |
--          | array a[Ie] | dict d[Ie] | dict d[Ib]
--          | Ifun (args)

EPlus.   IExpr  ::= IExpr "+" IExpr1;
EMinus.  IExpr  ::= IExpr "-" IExpr1;
EDiv.    IExpr1 ::= IExpr1 "/" IExpr2;
EMul.    IExpr1 ::= IExpr1 "*" IExpr2;
EMod.    IExpr1 ::= IExpr1 "%" IExpr2;
ENum.    IExpr2 ::= Integer;
EVar.    IExpr2 ::= VarIdent;

EPostInc. IExpr2 ::= VarIdent "++";
EPreInc.  IExpr2 ::= "++" VarIdent;
EPostDec. IExpr2 ::= VarIdent "--";
EPreDec.  IExpr2 ::= "--" VarIdent;

EArray.  IExpr2 ::= ArrIdent "[" IExpr "]";
EDict.   IExpr2 ::= DictIdent "[" IExpr "]";
EDictB.  IExpr2 ::= DictIdent "[" BExpr "]";

EFuncVal.   IExpr2 ::= FuncIdent "(" Args ")";

_.       IExpr2 ::= "(" IExpr ")"; -- We silently introduce parentheses
_.       IExpr1  ::= IExpr2;       -- We silently make IExpr1 and IExpr2 equal
_.       IExpr ::= IExpr1;         -- We silently make IExpr and IExpr1 equal

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for boolean expressions
-- Be ::= true | false | x | Ie1 == Ie2 | Ie1 <= Ie2 | Ie1 >= Ie2 | Ie1 < Ie2 | Ie1 > Ie2 | Ie1 != Ie2
--             | Be1 == Be2 | Be1 != Be2 | !Be | Be1 or Be2 | Be1 and Be2 | Be1 xor Be2
--             | array a[Ie] | dict d[Ie] | dict d[Be] | dict has key [Ie] | dict has key [Be]
--             | Bf (args)


BTrue.  BExpr1 ::= "true";
BFalse. BExpr1 ::= "false";
BVar.   BExpr1 ::= VarIdent;
BEq.    BExpr1 ::= IExpr "==" IExpr;
BLeq.   BExpr1 ::= IExpr "<=" IExpr;
BGeq.   BExpr1 ::= IExpr ">=" IExpr;
BLt.    BExpr1 ::= IExpr "<" IExpr;
BGt.    BExpr1 ::= IExpr ">" IExpr;
BNeq.   BExpr1 ::= IExpr "!=" IExpr;

BEqB.   BExpr1 ::= BExpr "==" BExpr;
BNeqB.  BExpr1 ::= BExpr "!=" BExpr;
BNot.   BExpr1 ::= "!" BExpr1;
-- && and || have the same priority (according to prof. Urzyczyn)
BOr.    BExpr1 ::= BExpr "or" BExpr1;
BAnd.   BExpr1 ::= BExpr "and" BExpr1;
BXor.   BExpr1 ::= BExpr "xor" BExpr1;

BArray. BExpr1 ::= ArrIdent "[" IExpr "]";
BDict.  BExpr1 ::= DictIdent "[" IExpr "]";
BDictB. BExpr1 ::= DictIdent "[" BExpr "]";
BDictHasKey.  BExpr1 ::= DictIdent "has" "key" "[" IExpr "]";
BDictHasKeyB. BExpr1 ::= DictIdent "has" "key" "[" BExpr "]";

BFuncVal.  BExpr1 ::= FuncIdent "(" Args ")";

_.       BExpr1 ::= "(" BExpr ")";
_.       BExpr ::= BExpr1;

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions that define the part of the grammar for parameters and arguments
-- args ::= none | e | e, args
-- Lambda ::= FType "lambda" (params) "->" { Instr }
-- params ::= none | VarIdent ":" Type | FuncIdent ":" FType | Lambda
--                 | VarIdent ":" Type, params | FuncIdent ":" FType, params | Lambda , params

ArgsNone. Args ::= "none";
ArgsOne.  Args ::= Expr;
ArgsMany. Args ::= Expr "," Args;

Lam. Lambda ::= FType "lambda" "(" Params ")" "->" "{" Instr "}";

ParamsNone.      Params ::= "none";
ParamVar.        Params ::= VarIdent ":" Type;
ParamFunc.       Params ::= FuncIdent ":" FType;
ParamLambda.     Params ::= Lambda;
ParamVarMany.    Params ::= VarIdent ":" Type "," Params;
ParamFuncMany.   Params ::= FuncIdent ":" FType "," Params;
ParamLambdaMany. Params ::= Lambda "," Params;

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for instructions
-- I ::= skip | I1; I2 | if (b) { I1 } else { I2 } | if (b) { I } | while (b) {I} | for (x = Ie1 to Ie2) { I }
--            | return (e) | print(e) | swap (x, y) | break | break (Ie) | continue | continue outer (Ie)
--            | vardef | funcdef | varassign | D
--            | d [e] set (e1) | a [e] = e1
-- D ::= debug assignment enable x | debug assignment disable x | debug reading enable x | debug reading disable x

ISkip.     Instr1 ::= "skip";
ISeq.      Instr ::= Instr1 ";" Instr; -- right associative, execution RtoL

-- We use this to declare a general form of expression, but parse it
-- differently.
internal IIf. Instr1 ::= "if" "(" BExpr ")" "{" Instr "}" "else" "{" Instr "}";
iif1.       Instr1 ::= "if" "(" BExpr ")" "{" Instr "}" "else" "{" Instr "}";
iif2.       Instr1 ::= "if" "(" BExpr ")" "{" Instr "}";
IWhile.     Instr1 ::= "while" "(" BExpr ")" "{" Instr "}";
IFor.       Instr1 ::= "for" "(" VarIdent "=" IExpr "to" IExpr ")" "{" Instr "}";

_. Instr ::= Instr1;

define iif1 b1 i1 i2 = IIf b1 i1 i2;
define iif2 b1 i1  = IIf b1 i1 ISkip;

IReturn.    Instr1 ::= "return" "(" IExpr ")";
IPrint.     Instr1 ::= "print" "(" IExpr ")";
ISwap.      Instr1 ::= "swap" "(" VarIdent "," VarIdent ")";
IBreak.     Instr1 ::= "break" "(" IExpr ")";
IBreak1.    Instr1 ::= "break";
IContinue.  Instr1 ::= "continue" "outer" "(" IExpr ")";
IContinue0. Instr1 ::= "continue";

-- Doesn't make sense
-- define ibreak = IBreak 1;
-- define icontinue = IContinue 0;

-- grammar for defining, assigning variables and functions

-- vardef ::= type VarIdent = Expr | Array type ArrIdent "[" Ie "]" (Ie) | Array type ArrIdent "[" e "]" | Dict type DictIdent
-- funcdef ::= FType FuncIdent (params) { I }
-- varassign ::= x = e | x += e | x -= e | x *= e | x /= e | x %= e

VarDef.        Instr1 ::= Type VarIdent "=" Expr;
ArrDefInit.    Instr1 ::= "Array" Type ArrIdent "[" IExpr "]" "(" Expr ")"; -- initialized with last argument
ArrDef.        Instr1 ::= "Array" Type ArrIdent "[" IExpr "]";
ArrElSet.      Instr1 ::= ArrIdent "[" IExpr "]" "=" "(" IExpr ")";
DictDef.       Instr1 ::= "Dict" Type DictIdent;
DictElSet.     Instr1 ::= DictIdent "[" IExpr "]" "set" "(" IExpr ")";

FuncDef.       Instr1 ::= FType FuncIdent "(" Params ")" "{" Instr "}";

VarAssign.         Instr1 ::= VarIdent "=" IExpr;
VarAssignPlus.     Instr1 ::= VarIdent "+=" IExpr;
VarAssignMinus.    Instr1 ::= VarIdent "-=" IExpr;
VarAssignMul.      Instr1 ::= VarIdent "*=" IExpr;
VarAssignDiv.      Instr1 ::= VarIdent "/=" IExpr;
VarAssignMod.      Instr1 ::= VarIdent "%=" IExpr;

-- grammar for debug instructions

DebugAssEnable.     Instr1 ::= "debug" "assignment" "enable" VarIdent;      -- ;)
DebugAssDisable.    Instr1 ::= "debug" "assignment" "disable" VarIdent;
DebugReadEnable.    Instr1 ::= "debug" "reading" "enable" VarIdent;
DebugReadDisable.   Instr1 ::= "debug" "reading" "disable" VarIdent;

-- --------------------------------------------------------------------------------------------- --