{-

This file contains the grammar of FraJer plus explanations how to render them
in BNFC.

-}

entrypoints Instr ;

-- Syntax for comments
comment "//" ;
comment "/*" "*/" ;

-- --------------------------------------------------------------------------------------------- --

-- BNFC Expressions for types and identifiers
-- T ::= int | bool
-- FT ::= Ifun | Bfun

TInt.  Type ::= "Int";
TBool. Type ::= "Bool";
FTInt. FType ::= "IntFunc";
FTBool. FType ::= "BoolFunc";

-- Probably will need to remove those, static type control is interpreter's job
Var. VarIdent ::= Ident;
Arr. ArrIdent ::= Ident;
Dict. DictIdent ::= Ident;
Func. FuncIdent ::= Ident;

-- --------------------------------------------------------------------------------------------- --

-- BNFC Expressions for general expressions

FuncVal.   Expr ::= FuncIdent "(" Args ")";
VarVal.    Expr ::= VarIdent;

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for int expressions (we do not distinguish between int and bool expressions,
-- static type control in the interpreter will do that)
-- Ie ::= N | x | Ie1 + e2 | Ie1 ∗ e2 | Ie1 − e2 | Ie1 % Ie2 | Ie1 / Ie2
--          | x++ | ++x | x-- | --x |
--          | array a[Ie] | dict d[Ie] | dict d[Ib]
--          | Ifun (args)

EPlus.   Expr  ::= Expr "+" Expr1;
EMinus.  Expr  ::= Expr "-" Expr1;
EDiv.    Expr1 ::= Expr1 "/" Expr2;
EMul.    Expr1 ::= Expr1 "*" Expr2;
EMod.    Expr1 ::= Expr1 "%" Expr2;
ENum.    Expr2 ::= Integer;

EPostInc. Expr2 ::= VarIdent "++";
EPreInc.  Expr2 ::= "++" VarIdent;
EPostDec. Expr2 ::= VarIdent "--";
EPreDec.  Expr2 ::= "--" VarIdent;

EArray.  Expr2 ::= ArrIdent "[" Expr "]";
EDict.   Expr2 ::= DictIdent "get" "[" Expr "]";

_.       Expr2 ::= "(" Expr ")"; -- We silently introduce parentheses
_.       Expr1  ::= Expr2;       -- We silently make Expr1 and Expr2 equal
_.       Expr ::= Expr1;         -- We silently make Expr and Expr1 equal

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for boolean expressions
-- Be ::= true | false | x | Ie1 == Ie2 | Ie1 <= Ie2 | Ie1 >= Ie2 | Ie1 < Ie2 | Ie1 > Ie2 | Ie1 != Ie2
--             | Be1 == Be2 | Be1 != Be2 | !Be | Be1 or Be2 | Be1 and Be2 | Be1 xor Be2
--             | array a[Ie] | dict d[Ie] | dict d[Be] | dict has key [Ie] | dict has key [Be]
--             | Bf (args)


BTrue.  Expr2 ::= "true";
BFalse. Expr2 ::= "false";
EEq.    Expr1 ::= Expr1 "==" Expr2;
ELeq.   Expr1 ::= Expr1 "<=" Expr2;
EGeq.   Expr1 ::= Expr1 ">=" Expr2;
ELt.    Expr1 ::= Expr1 "<" Expr2;
EGt.    Expr1 ::= Expr1 ">" Expr2;
ENeq.   Expr1 ::= Expr1 "!=" Expr2;

BNot.   Expr2 ::= "!" Expr2;
-- && and || have the same priority (according to prof. Urzyczyn), but lower than comparison operators
BOr.    Expr ::= Expr "or" Expr1;
BAnd.   Expr ::= Expr "and" Expr1;
BXor.   Expr ::= Expr "xor" Expr1;

BDictHasKey.  Expr2 ::= DictIdent "has" "key" "[" Expr "]";


-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions that define the part of the grammar for parameters and arguments
-- args ::= void | e | e, args | Lambda | Lambda, args
-- Lambda ::= FType "lambda" (params) "->" { Instr }
-- params ::= none | type x | ftype f
--                 | type x, params | ftype f , params

ArgsVoid. Args ::= "void";
ArgsOne.  Args ::= Expr;
ArgsMany. Args ::= Expr "," Args;
ArgsLambda. Args ::= Lambda;
ArgsLambdaMany. Args ::= Lambda "," Args;

ParamsNone.      Params ::= "none";
ParamVar.        Params ::= Type VarIdent;
ParamFunc.       Params ::= FType FuncIdent;
ParamVarMany.    Params ::= Type VarIdent "," Params;
ParamFuncMany.   Params ::= FType FuncIdent "," Params;

Lam. Lambda ::= FType "lambda" "(" Params ")" "->" "{" Instr "}";

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for instructions (statements and definitions)
-- I1; I2
ISeq.      Instr ::= Instr1 ";" Instr; -- right associative, execution RtoL
Stmt.      Instr1 ::= Stmt;
Def.       Instr1 ::= Def;

_. Instr ::= Instr1;

-- Grammar for statements
-- S ::= skip | if (b) { S1 } else { S2 } | if (b) { S } | while (b) {S} | for (x = Ie1 to Ie2) { S }
--            | return (e) | print(e) | swap (x, y) | break | break (Ie) | continue | continue outer (Ie)
--            | D
--            | d [e] set (e1) | a [e] = e1
-- D ::= debug assignment enable x | debug assignment disable x | debug reading enable x | debug reading disable x

SSkip.     Stmt ::= "skip";

-- We use this to declare a general form of expression, but parse it
-- differently.
internal SIf. Stmt ::= "if" "(" Expr ")" "{" Stmt "}" "else" "{" Stmt "}";
sif1.       Stmt ::= "if" "(" Expr ")" "{" Stmt "}" "else" "{" Stmt "}";
sif2.       Stmt ::= "if" "(" Expr ")" "{" Stmt "}";
SWhile.     Stmt ::= "while" "(" Expr ")" "{" Stmt "}";
SFor.       Stmt ::= "for" "(" VarIdent "=" Expr "to" Expr ")" "{" Stmt "}";


define sif1 b1 i1 i2 = SIf b1 i1 i2;
define sif2 b1 i1  = SIf b1 i1 SSkip;

SReturn.    Stmt ::= "return" "(" Expr ")";
SPrint.     Stmt ::= "print" "(" Expr ")";
SSwap.      Stmt ::= "swap" "(" VarIdent "," VarIdent ")";
SBreak.     Stmt ::= "break" "(" Expr ")";
SBreak1.    Stmt ::= "break";
SContinue.  Stmt ::= "continue" "outer" "(" Expr ")";
SContinue0. Stmt ::= "continue";

-- Doesn't make sense
-- define ibreak = IBreak 1;
-- define icontinue = IContinue 0;

-- grammar for defining variables and functions
-- vardef ::= type VarIdent = Expr | Array type ArrIdent "[" Ie "]" (Ie) | Array type ArrIdent "[" e "]" | Dict type DictIdent
-- funcdef ::= FType FuncIdent (params) { I }


VarDef.        Def ::= Type VarIdent "=" Expr;
FuncDef.       Def ::= FType FuncIdent "(" Params ")" "{" Stmt "}";

ArrDefInit.    Def ::= "Array" Type ArrIdent "[" Expr "]" "(" Expr ")"; -- initialized with last argument
ArrDef.        Def ::= "Array" Type ArrIdent "[" Expr "]";
DictDef.       Def ::= "Dict" Type DictIdent;

-- grammar for assigning variables
-- varassign ::= x = e | x += e | x -= e | x *= e | x /= e | x %= e

VarAssign.         Stmt ::= VarIdent "=" Expr;
VarAssignPlus.     Stmt ::= VarIdent "+=" Expr;
VarAssignMinus.    Stmt ::= VarIdent "-=" Expr;
VarAssignMul.      Stmt ::= VarIdent "*=" Expr;
VarAssignDiv.      Stmt ::= VarIdent "/=" Expr;
VarAssignMod.      Stmt ::= VarIdent "%=" Expr;

ArrElSet.      Stmt ::= ArrIdent "[" Expr "]" "=" "(" Expr ")";
DictElSet.     Stmt ::= DictIdent "set" "[" Expr "]" "to" "(" Expr ")";

-- grammar for debug instructions

DebugAssEnable.     Stmt ::= "debug" "assignment" "enable" VarIdent;      -- ;)
DebugAssDisable.    Stmt ::= "debug" "assignment" "disable" VarIdent;
DebugReadEnable.    Stmt ::= "debug" "reading" "enable" VarIdent;
DebugReadDisable.   Stmt ::= "debug" "reading" "disable" VarIdent;

-- --------------------------------------------------------------------------------------------- --