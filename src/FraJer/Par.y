-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module FraJer.Par
  ( happyError
  , myLexer
  , pInstr
  , pExpr
  , pStmt
  , pDef
  , pParams
  , pArgs
  , pLambda
  , pSType
  , pFType
  ) where

import Prelude

import qualified FraJer.Abs
import FraJer.Lex

}

%name pInstr Instr
%name pExpr Expr
%name pStmt Stmt
%name pDef Def
%name pParams Params
%name pArgs Args
%name pLambda Lambda
%name pSType SType
%name pFType FType
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'          { PT _ (TS _ 1)  }
  '!='         { PT _ (TS _ 2)  }
  '%'          { PT _ (TS _ 3)  }
  '%='         { PT _ (TS _ 4)  }
  '('          { PT _ (TS _ 5)  }
  ')'          { PT _ (TS _ 6)  }
  '*'          { PT _ (TS _ 7)  }
  '*='         { PT _ (TS _ 8)  }
  '+'          { PT _ (TS _ 9)  }
  '++'         { PT _ (TS _ 10) }
  '+='         { PT _ (TS _ 11) }
  ','          { PT _ (TS _ 12) }
  '-'          { PT _ (TS _ 13) }
  '--'         { PT _ (TS _ 14) }
  '-='         { PT _ (TS _ 15) }
  '->'         { PT _ (TS _ 16) }
  '/'          { PT _ (TS _ 17) }
  '/='         { PT _ (TS _ 18) }
  ';'          { PT _ (TS _ 19) }
  '<'          { PT _ (TS _ 20) }
  '<='         { PT _ (TS _ 21) }
  '='          { PT _ (TS _ 22) }
  '=='         { PT _ (TS _ 23) }
  '>'          { PT _ (TS _ 24) }
  '>='         { PT _ (TS _ 25) }
  'Array'      { PT _ (TS _ 26) }
  'Bool'       { PT _ (TS _ 27) }
  'BoolFunc'   { PT _ (TS _ 28) }
  'Dict'       { PT _ (TS _ 29) }
  'Int'        { PT _ (TS _ 30) }
  'IntFunc'    { PT _ (TS _ 31) }
  '['          { PT _ (TS _ 32) }
  ']'          { PT _ (TS _ 33) }
  'and'        { PT _ (TS _ 34) }
  'assignment' { PT _ (TS _ 35) }
  'break'      { PT _ (TS _ 36) }
  'continue'   { PT _ (TS _ 37) }
  'debug'      { PT _ (TS _ 38) }
  'disable'    { PT _ (TS _ 39) }
  'else'       { PT _ (TS _ 40) }
  'enable'     { PT _ (TS _ 41) }
  'false'      { PT _ (TS _ 42) }
  'for'        { PT _ (TS _ 43) }
  'get'        { PT _ (TS _ 44) }
  'has'        { PT _ (TS _ 45) }
  'if'         { PT _ (TS _ 46) }
  'key'        { PT _ (TS _ 47) }
  'lambda'     { PT _ (TS _ 48) }
  'none'       { PT _ (TS _ 49) }
  'or'         { PT _ (TS _ 50) }
  'outer'      { PT _ (TS _ 51) }
  'print'      { PT _ (TS _ 52) }
  'reading'    { PT _ (TS _ 53) }
  'return'     { PT _ (TS _ 54) }
  'set'        { PT _ (TS _ 55) }
  'skip'       { PT _ (TS _ 56) }
  'swap'       { PT _ (TS _ 57) }
  'to'         { PT _ (TS _ 58) }
  'true'       { PT _ (TS _ 59) }
  'void'       { PT _ (TS _ 60) }
  'while'      { PT _ (TS _ 61) }
  'xor'        { PT _ (TS _ 62) }
  '{'          { PT _ (TS _ 63) }
  '}'          { PT _ (TS _ 64) }
  L_Ident      { PT _ (TV $$)   }
  L_integ      { PT _ (TI $$)   }

%%

Ident :: { FraJer.Abs.Ident }
Ident  : L_Ident { FraJer.Abs.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

SType :: { FraJer.Abs.SType }
SType : 'Int' { FraJer.Abs.STInt } | 'Bool' { FraJer.Abs.STBool }

FType :: { FraJer.Abs.FType }
FType
  : 'IntFunc' { FraJer.Abs.FTInt } | 'BoolFunc' { FraJer.Abs.FTBool }

Expr2 :: { FraJer.Abs.Expr }
Expr2
  : Ident '(' Args ')' { FraJer.Abs.FuncVal $1 $3 }
  | Ident { FraJer.Abs.VarVal $1 }
  | Integer { FraJer.Abs.ENum $1 }
  | Ident '++' { FraJer.Abs.EPostInc $1 }
  | '++' Ident { FraJer.Abs.EPreInc $2 }
  | Ident '--' { FraJer.Abs.EPostDec $1 }
  | '--' Ident { FraJer.Abs.EPreDec $2 }
  | Ident '[' Expr ']' { FraJer.Abs.EArray $1 $3 }
  | Ident 'get' '[' Expr ']' { FraJer.Abs.EDict $1 $4 }
  | '(' Expr ')' { $2 }
  | 'true' { FraJer.Abs.BTrue }
  | 'false' { FraJer.Abs.BFalse }
  | '!' Expr2 { FraJer.Abs.BNot $2 }
  | Ident 'has' 'key' '[' Expr ']' { FraJer.Abs.BDictHasKey $1 $5 }

Expr :: { FraJer.Abs.Expr }
Expr
  : Expr '+' Expr1 { FraJer.Abs.EPlus $1 $3 }
  | Expr '-' Expr1 { FraJer.Abs.EMinus $1 $3 }
  | Expr1 { $1 }
  | Expr 'or' Expr1 { FraJer.Abs.BOr $1 $3 }
  | Expr 'and' Expr1 { FraJer.Abs.BAnd $1 $3 }
  | Expr 'xor' Expr1 { FraJer.Abs.BXor $1 $3 }

Expr1 :: { FraJer.Abs.Expr }
Expr1
  : Expr1 '/' Expr2 { FraJer.Abs.EDiv $1 $3 }
  | Expr1 '*' Expr2 { FraJer.Abs.EMul $1 $3 }
  | Expr1 '%' Expr2 { FraJer.Abs.EMod $1 $3 }
  | Expr2 { $1 }
  | Expr1 '==' Expr2 { FraJer.Abs.EEq $1 $3 }
  | Expr1 '<=' Expr2 { FraJer.Abs.ELeq $1 $3 }
  | Expr1 '>=' Expr2 { FraJer.Abs.EGeq $1 $3 }
  | Expr1 '<' Expr2 { FraJer.Abs.ELt $1 $3 }
  | Expr1 '>' Expr2 { FraJer.Abs.EGt $1 $3 }
  | Expr1 '!=' Expr2 { FraJer.Abs.ENeq $1 $3 }

Args :: { FraJer.Abs.Args }
Args
  : 'void' { FraJer.Abs.ArgsVoid }
  | Expr { FraJer.Abs.ArgsOne $1 }
  | Expr ',' Args { FraJer.Abs.ArgsMany $1 $3 }
  | Lambda { FraJer.Abs.ArgsLambda $1 }
  | Lambda ',' Args { FraJer.Abs.ArgsLambdaMany $1 $3 }

Params :: { FraJer.Abs.Params }
Params
  : 'none' { FraJer.Abs.ParamsNone }
  | SType Ident { FraJer.Abs.ParamVar $1 $2 }
  | FType Ident { FraJer.Abs.ParamFunc $1 $2 }
  | SType Ident ',' Params { FraJer.Abs.ParamVarMany $1 $2 $4 }
  | FType Ident ',' Params { FraJer.Abs.ParamFuncMany $1 $2 $4 }

Lambda :: { FraJer.Abs.Lambda }
Lambda
  : FType 'lambda' '(' Params ')' '->' '{' Instr '}' { FraJer.Abs.Lam $1 $4 $8 }

Instr :: { FraJer.Abs.Instr }
Instr : Instr1 ';' Instr { FraJer.Abs.ISeq $1 $3 } | Instr1 { $1 }

Instr1 :: { FraJer.Abs.Instr }
Instr1
  : Def { FraJer.Abs.IDef $1 }
  | Stmt { FraJer.Abs.IStmt $1 }
  | SpecStmt { FraJer.Abs.ISpecStmt $1 }

Def1 :: { FraJer.Abs.Def }
Def1
  : SType Ident '=' Expr { FraJer.Abs.VarDef $1 $2 $4 }
  | FType Ident '(' Params ')' '{' Instr '}' { FraJer.Abs.FuncDef $1 $2 $4 $7 }
  | 'Array' SType Ident '[' Expr ']' '(' Expr ')' { FraJer.Abs.ArrDefInit $2 $3 $5 $8 }
  | 'Array' SType Ident '[' Expr ']' { FraJer.Abs.ArrDef $2 $3 $5 }
  | 'Dict' SType Ident { FraJer.Abs.DictDef $2 $3 }

Def :: { FraJer.Abs.Def }
Def : Def1 { $1 }

Stmt1 :: { FraJer.Abs.Stmt }
Stmt1
  : 'if' '(' Expr ')' '{' Instr '}' 'else' '{' Instr '}' { FraJer.Abs.sif1 $3 $6 $10 }
  | 'if' '(' Expr ')' '{' Instr '}' { FraJer.Abs.sif2 $3 $6 }
  | 'while' '(' Expr ')' '{' Instr '}' { FraJer.Abs.SWhile $3 $6 }
  | 'for' '(' Ident '=' Expr 'to' Expr ')' '{' Instr '}' { FraJer.Abs.SFor $3 $5 $7 $10 }
  | 'skip' { FraJer.Abs.SSkip }
  | 'return' '(' Expr ')' { FraJer.Abs.SReturn $3 }
  | 'print' '(' Expr ')' { FraJer.Abs.SPrint $3 }
  | 'break' '(' Expr ')' { FraJer.Abs.SBreak $3 }
  | 'break' { FraJer.Abs.SBreak1 }
  | 'continue' 'outer' '(' Expr ')' { FraJer.Abs.SContinue $4 }
  | 'continue' { FraJer.Abs.SContinue0 }
  | Ident '=' Expr { FraJer.Abs.VarAssign $1 $3 }
  | Ident '+=' Expr { FraJer.Abs.VarAssignPlus $1 $3 }
  | Ident '-=' Expr { FraJer.Abs.VarAssignMinus $1 $3 }
  | Ident '*=' Expr { FraJer.Abs.VarAssignMul $1 $3 }
  | Ident '/=' Expr { FraJer.Abs.VarAssignDiv $1 $3 }
  | Ident '%=' Expr { FraJer.Abs.VarAssignMod $1 $3 }
  | Ident '[' Expr ']' '=' '(' Expr ')' { FraJer.Abs.ArrElSet $1 $3 $7 }
  | Ident 'set' '[' Expr ']' 'to' '(' Expr ')' { FraJer.Abs.DictElSet $1 $4 $8 }

Stmt :: { FraJer.Abs.Stmt }
Stmt : Stmt1 { $1 }

SpecStmt :: { FraJer.Abs.SpecStmt }
SpecStmt
  : 'swap' '(' Ident ',' Ident ')' { FraJer.Abs.SSwap $3 $5 }
  | 'debug' 'assignment' 'enable' Ident { FraJer.Abs.DebugAssEnable $4 }
  | 'debug' 'assignment' 'disable' Ident { FraJer.Abs.DebugAssDisable $4 }
  | 'debug' 'reading' 'enable' Ident { FraJer.Abs.DebugReadEnable $4 }
  | 'debug' 'reading' 'disable' Ident { FraJer.Abs.DebugReadDisable $4 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

