/* Funkcja obliczająca i wypisująca drogę liczby w problemie 3n + 1 */
IntFunc collatz(Int n) {
    print(n);
    while (n != 1) {
        if (n % 2 == 0) {
            n = n / 2
        } else {
            n = 3 * n + 1
        };
        print(n);
    };
    return(0) 
};

/* Funkcja obliczająca silnię */
IntFunc silnia(Int n) {
    while (n-->1) {
        return ((n+1) * silnia (n))
    };
    return (1)
};

/* silnia w pętli */
IntFunc silniaPetla(Int n) {
    Int res = 1;
    for (i = 1 to n) {
        
        res *= i;
    };
    return (res);
};

/* Funkcja obliczająca n-tą liczbę Fibonacciego */
IntFunc fibonacci(Int n) {
    if (n <= 1) {
        return (n)
    } else {
        return (fibonacci(n - 1) + fibonacci(n - 2))
    }
};



/* Funkcja Sito Eratostenesa */
IntFunc sieve(Int n) {
    Array Int primes[n+1] (1); /* Tablica oznaczająca liczby jako potencjalnie pierwsze */    
    /* Inicjalizacja tablicy, wszystkie liczby ustawiamy na 1 (potencjalnie pierwsze) */

    primes[0] = (0); /* 0 nie jest liczbą pierwszą */
    primes[1] = (0); /* 1 nie jest liczbą pierwszą */

    /* Główna pętla algorytmu Sita Eratostenesa */
    for (p = 2 to n) {
        if (primes[p] == 1) {  /* Jeśli liczba jest pierwsza */
            for (i = (p * p) to n) { /* Oznaczanie wielokrotności jako niepierwsze */
                if (i % p == 0) {
                    primes[i] = (0) /* Oznacz liczby jako niepierwsze */
                }
            }
        };
    };

    /* Wypisanie liczb pierwszych */
    for (i = 2 to n) {
        if (primes[i] == 1) {  /* Jeśli liczba jest pierwsza */
            print(i)          /* Wypisz liczbę */
        }
    };
};


IntFunc gcd(Int a, Int b) {
    debug assignment enable a;
    debug assignment enable b;

    while (b != 0) {
        a = a%b;
        swap (a, b);
        skip;
    };
    return (a);
};

IntFunc petla(Int n) {
    Int i = 0;
    while (i < n) {
        i = i + 1;
        print(i);
    };
    return (0);
};

IntFunc zlozenie(IntFunc x, BoolFunc y, Int n) {
    return (y(x(x(n))));
};

print(zlozenie(IntFunc lambda (Int x) -> {return (x*x)}, BoolFunc lambda (Int x) -> {return (x == 10000)}, 10));