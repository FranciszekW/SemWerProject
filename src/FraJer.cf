{-

This file contains the grammar of FraJer plus explanations how to render them
in BNFC.

-}

entrypoints Instr, Expr, Stmt, Def, Params, Args, Lambda, SimpleType, FuncType;

-- Syntax for comments
comment "//" ;
comment "/*" "*/" ;

-- --------------------------------------------------------------------------------------------- --

-- BNFC Expressions for types and identifiers
-- ST ::= int | bool
-- FT ::= Ifun | Bfun

STInt.  SSTInt ::= "Int";
STBool. SSTBool ::= "Bool";
FTInt. FFTInt ::= "IntFunc";
FTBool. FFTBool ::= "BoolFunc";

STI. SimpleType ::= SSTInt;
STB. SimpleType ::= SSTBool;
FTI. FuncType ::= FFTInt;
FTB. FuncType ::= FFTBool;

-- --------------------------------------------------------------------------------------------- --

-- BNFC Expressions for general expressions

FuncVal.   Expr2 ::= Ident "(" Args ")";
VarVal.    Expr2 ::= Ident;

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for int expressions (we do not distinguish between int and bool expressions,
-- static type control in the interpreter will do that)
-- Ie ::= N | x | Ie1 + e2 | Ie1 ∗ e2 | Ie1 − e2 | Ie1 % Ie2 | Ie1 / Ie2
--          | x++ | ++x | x-- | --x |
--          | array a[Ie] | dict d[Ie] | dict d[Ib]
--          | Ifun (args)

EPlus.   Expr  ::= Expr "+" Expr1;
EMinus.  Expr  ::= Expr "-" Expr1;
EDiv.    Expr1 ::= Expr1 "/" Expr2;
EMul.    Expr1 ::= Expr1 "*" Expr2;
EMod.    Expr1 ::= Expr1 "%" Expr2;
ENum.    Expr2 ::= Integer;
ENeg.    Expr3 ::= "-" Expr2;

EPostInc. Expr2 ::= Ident "++";
EPreInc.  Expr2 ::= "++" Ident;
EPostDec. Expr2 ::= Ident "--";
EPreDec.  Expr2 ::= "--" Ident;

EArray.  Expr2 ::= Ident "[" Expr "]";
EDict.   Expr2 ::= Ident "get" "[" Expr "]";

_.       Expr3 ::= "(" Expr ")"; -- We silently introduce parentheses
_.       Expr2 ::= Expr3;         -- We silently make Expr2 and Expr3 equal
_.       Expr1 ::= Expr2;       -- We silently make Expr1 and Expr2 equal
_.       Expr  ::= Expr1;         -- We silently make Expr and Expr1 equal

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for boolean expressions
-- Be ::= true | false | x | Ie1 == Ie2 | Ie1 <= Ie2 | Ie1 >= Ie2 | Ie1 < Ie2 | Ie1 > Ie2 | Ie1 != Ie2
--             | Be1 == Be2 | Be1 != Be2 | !Be | Be1 or Be2 | Be1 and Be2 | Be1 xor Be2
--             | array a[Ie] | dict d[Ie] | dict d[Be] | dict has key [Ie] | dict has key [Be]
--             | Bf (args)


BTrue.  Expr2 ::= "true";
BFalse. Expr2 ::= "false";
EEq.    Expr1 ::= Expr1 "==" Expr2;
ELeq.   Expr1 ::= Expr1 "<=" Expr2;
EGeq.   Expr1 ::= Expr1 ">=" Expr2;
ELt.    Expr1 ::= Expr1 "<" Expr2;
EGt.    Expr1 ::= Expr1 ">" Expr2;
ENeq.   Expr1 ::= Expr1 "!=" Expr2;

BNot.   Expr2 ::= "!" Expr2;
-- && and || have the same priority (according to prof. Urzyczyn), but lower than comparison operators
BOr.    Expr ::= Expr "or" Expr1;
BAnd.   Expr ::= Expr "and" Expr1;
BXor.   Expr ::= Expr "xor" Expr1;

BDictHasKey.  Expr2 ::= Ident "has" "key" "[" Expr "]";


-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions that define the part of the grammar for parameters and arguments
-- args ::= void | e | e, args | Lambda | Lambda, args | f, args | f
-- Lambda ::= FuncType "lambda" (params) "->" { Instr }
-- params ::= none | type x | ftype (params) f
--                 | type x, params | ftype (params) f , params

ArgsVoid. Args ::= "void";
ArgsOne.  Args ::= Expr;
ArgsMany. Args ::= Expr "," Args;
ArgsLambda. Args ::= Lambda;
ArgsLambdaMany. Args ::= Lambda "," Args;
ArgsFunc. Args ::= "func" Ident;
ArgsFuncMany. Args ::= "func" Ident "," Args;

ParamsNone.      Params ::= "none";
ParamVar.        Params ::= SimpleType Ident;
ParamFunc.       Params ::= FuncType "(" Params ")" Ident;
ParamVarMany.    Params ::= SimpleType Ident "," Params;
ParamFuncMany.   Params ::= FuncType "(" Params ")" Ident "," Params;

Lam. Lambda ::= FuncType "lambda" "(" Params ")" "->" "{" Instr "}";

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for instructions (statements and definitions)
-- I1; I2
ISeq.       Instr ::= Instr1 ";" Instr; -- right associative, execution RtoL
IDef.       Instr1 ::= Def;
IStmt.      Instr1 ::= Stmt;
ISpecStmt.  Instr1 ::= SpecStmt;

_. Instr ::= Instr1;
_. Instr1 ::= Instr1 ";";

-- Grammar for defining variables and functions
-- vardef ::= type Ident = Expr | Array type Ident "[" Ie "]" (Ie) | Array type Ident "[" e "]" | Dict type Ident
-- funcdef ::= FuncType Ident (params) { I }

VarDef.        Def1 ::= SimpleType Ident "=" Expr;

-- functions can also have local variables inside, so we allow declarations in the function body
FuncDef.       Def1 ::= FuncType Ident "(" Params ")" "{" Instr "}";

ArrDefInit.    Def1 ::= "Array" SimpleType Ident "[" Expr "]" "(" Expr ")"; -- initialized with last argument
ArrDef.        Def1 ::= "Array" SimpleType Ident "[" Expr "]";
DictDef.       Def1 ::= "Dict" SimpleType Ident;

_. Def ::= Def1;

-- Grammar for statements
-- S ::= skip | S1, S2 | if (b) { S1 } else { S2 } | if (b) { S } | while (b) {S} | for (x = Ie1 to Ie2) { S }
--            | return (e) | print(e) | swap (x, y) | break | break (Ie) | continue | continue outer (Ie)
--            | D
--            | d [e] set (e1) | a [e] = e1
-- D ::= debug assignment enable x | debug assignment disable x | debug reading enable x | debug reading disable x

-- We use this to declare a general form of expression, but parse it
-- differently.
internal SIf. Stmt1 ::= "if" "(" Expr ")" "{" Instr "}" "else" "{" Instr "}";
sif1.       Stmt1 ::= "if" "(" Expr ")" "{" Instr "}" "else" "{" Instr "}";
sif2.       Stmt1 ::= "if" "(" Expr ")" "{" Instr "}";
SWhile.     Stmt1 ::= "while" "(" Expr ")" "{" Instr "}";
SFor.       Stmt1 ::= "for" "(" Ident "=" Expr "to" Expr ")" "{" Instr "}";


define sif1 b1 i1 i2 = SIf b1 i1 i2;
define sif2 b1 i1  = SIf b1 i1 (IStmt SSkip);

SSkip.      Stmt1 ::= "skip";
SReturn.    Stmt1 ::= "return" "(" Expr ")";
SPrint.     Stmt1 ::= "print" "(" Expr ")";
SBreak.     Stmt1 ::= "break" "(" Expr ")";
SBreak1.    Stmt1 ::= "break";
SContinue.  Stmt1 ::= "continue" "outer" "(" Expr ")";
SContinue0. Stmt1 ::= "continue";

-- Doesn't make sense
-- define ibreak = IBreak 1;
-- define icontinue = IContinue 0;

-- grammar for assigning variables
-- varassign ::= x = e | x += e | x -= e | x *= e | x /= e | x %= e

VarAssign.         Stmt1 ::= Ident "=" Expr;
VarAssignPlus.     Stmt1 ::= Ident "+=" Expr;
VarAssignMinus.    Stmt1 ::= Ident "-=" Expr;
VarAssignMul.      Stmt1 ::= Ident "*=" Expr;
VarAssignDiv.      Stmt1 ::= Ident "/=" Expr;
VarAssignMod.      Stmt1 ::= Ident "%=" Expr;
VarInc.            Stmt1 ::= "++" Ident;
varInc.            Stmt1 ::= Ident "++";
VarDec.            Stmt1 ::= "--" Ident;
varDec.            Stmt1 ::= Ident "--";

ArrElSet.      Stmt1 ::= Ident "[" Expr "]" "=" "(" Expr ")";
DictElSet.     Stmt1 ::= Ident "set" "[" Expr "]" "to" "(" Expr ")";

_. Stmt ::= Stmt1;

define varInc x = VarInc x;
define varDec x = VarDec x;

---------------------------------SPECIAL STATEMENTS-----------------------------------------------
-- Debugging and swapping for now.

SSwap.              SpecStmt ::= "swap" "(" Ident "," Ident ")";
DebugAssEnable.     SpecStmt ::= "debug" "assignment" "enable" Ident;      -- ;)
DebugAssDisable.    SpecStmt ::= "debug" "assignment" "disable" Ident;
DebugReadEnable.    SpecStmt ::= "debug" "reading" "enable" Ident;
DebugReadDisable.   SpecStmt ::= "debug" "reading" "disable" Ident;

-- --------------------------------------------------------------------------------------------- --