{-

This file contains the grammar of FraJer plus explanations how to render them
in BNFC.

-}

entrypoints Instr ;

-- Syntax for comments
comment "//" ;
comment "/*" "*/" ;

-- --------------------------------------------------------------------------------------------- --

-- BNFC Expressions for types and identifiers
-- T ::= int | bool
-- FT ::= Ifun | Bfun

TInt.  Type ::= "Int";
TBool. Type ::= "Bool";
FTInt. FType ::= "IntFunc";
FTBool. FType ::= "BoolFunc";

-- Probably will need to remove those, static type control is interpreter's job
Var. VarIdent ::= Ident;
Arr. ArrIdent ::= Ident;
Dict. DictIdent ::= Ident;
Func. FuncIdent ::= Ident;

-- --------------------------------------------------------------------------------------------- --

-- BNFC Expressions for general expressions

FuncVal.   Expr ::= FuncIdent "(" Args ")";
VarVal.    Expr ::= VarIdent;

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for int expressions (we do not distinguish between int and bool expressions,
-- static type control in the interpreter will do that)
-- Ie ::= N | x | Ie1 + e2 | Ie1 ∗ e2 | Ie1 − e2 | Ie1 % Ie2 | Ie1 / Ie2
--          | x++ | ++x | x-- | --x |
--          | array a[Ie] | dict d[Ie] | dict d[Ib]
--          | Ifun (args)

EPlus.   Expr  ::= Expr "+" Expr1;
EMinus.  Expr  ::= Expr "-" Expr1;
EDiv.    Expr1 ::= Expr1 "/" Expr2;
EMul.    Expr1 ::= Expr1 "*" Expr2;
EMod.    Expr1 ::= Expr1 "%" Expr2;
ENum.    Expr2 ::= Integer;

EPostInc. Expr2 ::= VarIdent "++";
EPreInc.  Expr2 ::= "++" VarIdent;
EPostDec. Expr2 ::= VarIdent "--";
EPreDec.  Expr2 ::= "--" VarIdent;

EArray.  Expr2 ::= ArrIdent "[" Expr "]";
EDict.   Expr2 ::= DictIdent "get" "[" Expr "]";

_.       Expr2 ::= "(" Expr ")"; -- We silently introduce parentheses
_.       Expr1  ::= Expr2;       -- We silently make Expr1 and Expr2 equal
_.       Expr ::= Expr1;         -- We silently make Expr and Expr1 equal

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for boolean expressions
-- Be ::= true | false | x | Ie1 == Ie2 | Ie1 <= Ie2 | Ie1 >= Ie2 | Ie1 < Ie2 | Ie1 > Ie2 | Ie1 != Ie2
--             | Be1 == Be2 | Be1 != Be2 | !Be | Be1 or Be2 | Be1 and Be2 | Be1 xor Be2
--             | array a[Ie] | dict d[Ie] | dict d[Be] | dict has key [Ie] | dict has key [Be]
--             | Bf (args)


BTrue.  Expr2 ::= "true";
BFalse. Expr2 ::= "false";
EEq.    Expr1 ::= Expr1 "==" Expr2;
ELeq.   Expr1 ::= Expr1 "<=" Expr2;
EGeq.   Expr1 ::= Expr1 ">=" Expr2;
ELt.    Expr1 ::= Expr1 "<" Expr2;
EGt.    Expr1 ::= Expr1 ">" Expr2;
ENeq.   Expr1 ::= Expr1 "!=" Expr2;

BNot.   Expr2 ::= "!" Expr2;
-- && and || have the same priority (according to prof. Urzyczyn), but lower than comparison operators
BOr.    Expr ::= Expr "or" Expr1;
BAnd.   Expr ::= Expr "and" Expr1;
BXor.   Expr ::= Expr "xor" Expr1;

BDictHasKey.  Expr2 ::= DictIdent "has" "key" "[" Expr "]";


-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions that define the part of the grammar for parameters and arguments
-- args ::= void | e | e, args | Lambda | Lambda, args
-- Lambda ::= FType "lambda" (params) "->" { Instr }
-- params ::= none | type x | ftype f
--                 | type x, params | ftype f , params

ArgsVoid. Args ::= "void";
ArgsOne.  Args ::= Expr;
ArgsMany. Args ::= Expr "," Args;
ArgsLambda. Args ::= Lambda;
ArgsLambdaMany. Args ::= Lambda "," Args;

ParamsNone.      Params ::= "none";
ParamVar.        Params ::= Type VarIdent;
ParamFunc.       Params ::= FType FuncIdent;
ParamVarMany.    Params ::= Type VarIdent "," Params;
ParamFuncMany.   Params ::= FType FuncIdent "," Params;

Lam. Lambda ::= FType "lambda" "(" Params ")" "->" "{" Instr "}";

-- --------------------------------------------------------------------------------------------- --

-- BNFC expressions for instructions
-- I ::= skip | I1; I2 | if (b) { I1 } else { I2 } | if (b) { I } | while (b) {I} | for (x = Ie1 to Ie2) { I }
--            | return (e) | print(e) | swap (x, y) | break | break (Ie) | continue | continue outer (Ie)
--            | vardef | funcdef | varassign | D
--            | d [e] set (e1) | a [e] = e1
-- D ::= debug assignment enable x | debug assignment disable x | debug reading enable x | debug reading disable x

ISeq.      Instr ::= Instr1 ";" Instr; -- right associative, execution RtoL -- glupie to, ale trzeba
ISkip.     Instr1 ::= "skip"; -- glupie to, ale trzeba

-- We use this to declare a general form of expression, but parse it
-- differently.
internal IIf. Instr1 ::= "if" "(" Expr ")" "{" Instr "}" "else" "{" Instr "}";
iif1.       Instr1 ::= "if" "(" Expr ")" "{" Instr "}" "else" "{" Instr "}";
iif2.       Instr1 ::= "if" "(" Expr ")" "{" Instr "}";
IWhile.     Instr1 ::= "while" "(" Expr ")" "{" Instr "}";
IFor.       Instr1 ::= "for" "(" VarIdent "=" Expr "to" Expr ")" "{" Instr "}";

_. Instr ::= Instr1;

define iif1 b1 i1 i2 = IIf b1 i1 i2;
define iif2 b1 i1  = IIf b1 i1 ISkip;

IReturn.    Instr1 ::= "return" "(" Expr ")";
IPrint.     Instr1 ::= "print" "(" Expr ")";
ISwap.      Instr1 ::= "swap" "(" VarIdent "," VarIdent ")";
IBreak.     Instr1 ::= "break" "(" Expr ")";
IBreak1.    Instr1 ::= "break";
IContinue.  Instr1 ::= "continue" "outer" "(" Expr ")";
IContinue0. Instr1 ::= "continue";

-- Doesn't make sense
-- define ibreak = IBreak 1;
-- define icontinue = IContinue 0;

-- grammar for defining, assigning variables and functions

-- vardef ::= type VarIdent = Expr | Array type ArrIdent "[" Ie "]" (Ie) | Array type ArrIdent "[" e "]" | Dict type DictIdent
-- funcdef ::= FType FuncIdent (params) { I }
-- varassign ::= x = e | x += e | x -= e | x *= e | x /= e | x %= e

VarDef.        Instr1 ::= Type VarIdent "=" Expr;
ArrDefInit.    Instr1 ::= "Array" Type ArrIdent "[" Expr "]" "(" Expr ")"; -- initialized with last argument
ArrDef.        Instr1 ::= "Array" Type ArrIdent "[" Expr "]";
ArrElSet.      Instr1 ::= ArrIdent "[" Expr "]" "=" "(" Expr ")";
DictDef.       Instr1 ::= "Dict" Type DictIdent;
DictElSet.     Instr1 ::= DictIdent "set" "[" Expr "]" "to" "(" Expr ")";

FuncDef.       Instr1 ::= FType FuncIdent "(" Params ")" "{" Instr "}";

VarAssign.         Instr1 ::= VarIdent "=" Expr;
VarAssignPlus.     Instr1 ::= VarIdent "+=" Expr;
VarAssignMinus.    Instr1 ::= VarIdent "-=" Expr;
VarAssignMul.      Instr1 ::= VarIdent "*=" Expr;
VarAssignDiv.      Instr1 ::= VarIdent "/=" Expr;
VarAssignMod.      Instr1 ::= VarIdent "%=" Expr;

-- grammar for debug instructions

DebugAssEnable.     Instr1 ::= "debug" "assignment" "enable" VarIdent;      -- ;)
DebugAssDisable.    Instr1 ::= "debug" "assignment" "disable" VarIdent;
DebugReadEnable.    Instr1 ::= "debug" "reading" "enable" VarIdent;
DebugReadDisable.   Instr1 ::= "debug" "reading" "disable" VarIdent;

-- --------------------------------------------------------------------------------------------- --